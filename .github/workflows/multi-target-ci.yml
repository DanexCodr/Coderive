name: Multi-Target Coderive Compilation

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

jobs:
  # Build and test the Java compiler itself
  build-compiler:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
    
    - name: Build Java compiler with ANTLR runtime
      run: |
        # Compile with ANTLR runtime from root lib/
        find src/main/java -name "*.java" > sources.txt
        mkdir -p target/classes
        javac -cp "lib/antlr4-runtime-4.13.2.jar" -d target/classes @sources.txt
        echo "Java compiler built successfully"
    
    - name: Test basic functionality
      run: |
        # Test that the compiler can be loaded and run
        java -cp "target/classes:lib/antlr4-runtime-4.13.2.jar" cdrv.runner.CompilerRunner --help || echo "Help test completed"
        echo "Basic functionality test passed"

  # Multi-architecture compilation
  multi-arch-compile:
    runs-on: ubuntu-latest
    needs: build-compiler
    strategy:
      matrix:
        target: [aarch64, x86_64]
        include:
          - target: aarch64
            as: aarch64-linux-gnu-as
            objdump: aarch64-linux-gnu-objdump
            gcc: aarch64-linux-gnu-gcc
          - target: x86_64  
            as: as
            objdump: objdump
            gcc: gcc
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
    
    - name: Set up cross-compilation tools for ${{ matrix.target }}
      run: |
        if [ "${{ matrix.target }}" = "aarch64" ]; then
          sudo apt-get update
          sudo apt-get install -y binutils-aarch64-linux-gnu gcc-aarch64-linux-gnu
        else
          sudo apt-get install -y binutils gcc
        fi
    
    - name: Build Java compiler
      run: |
        find src/main/java -name "*.java" > sources.txt
        mkdir -p target/classes
        javac -cp "lib/antlr4-runtime-4.13.2.jar" -d target/classes @sources.txt
    
    - name: Test compilation with actual .cdrv files
      run: |
       echo "Available .cdrv files:"
       find src/main/cdrv -name "*.cdrv" -type f
    
       # Use the first .cdrv file found for testing
       FIRST_CDRV=$(find src/main/cdrv -name "*.cdrv" -type f | head -1)
       if [ -n "$FIRST_CDRV" ]; then
         echo "Testing with: $FIRST_CDRV"
      
         # Test bytecode compilation
         java -cp "target/classes:lib/antlr4-runtime-4.13.2.jar" cdrv.runner.CompilerRunner --bytecode "$FIRST_CDRV"
      
         # Test native compilation
         java -cp "target/classes:lib/antlr4-runtime-4.13.2.jar" cdrv.runner.CompilerRunner --native "$FIRST_CDRV"
       else
         echo "No .cdrv files found in src/main/cdrv/"
         # Create a simple test file using echo
         mkdir -p src/main/cdrv
         echo 'output "Multi-arch compilation test"' > src/main/cdrv/test.cdrv
         echo 'x = 10 + 5' >> src/main/cdrv/test.cdrv
         echo 'output "Result: " + x' >> src/main/cdrv/test.cdrv
         echo 'for i in 1 to 3 {' >> src/main/cdrv/test.cdrv
         echo '  output "Loop: " + i' >> src/main/cdrv/test.cdrv
         echo '}' >> src/main/cdrv/test.cdrv
         java -cp "target/classes:lib/antlr4-runtime-4.13.2.jar" cdrv.runner.CompilerRunner --native src/main/cdrv/test.cdrv
       fi
    
    - name: Verify assembly generation
      run: |
       # Create necessary directories
       mkdir -p src/main/cdrv
       mkdir -p src/generated
    
       # Ensure we have a test .cdrv file
       if [ ! -f "src/main/cdrv/test.cdrv" ]; then
         cat > src/main/cdrv/test.cdrv << 'EOF'
         output "Multi-arch compilation test"
         x = 10 + 5
         output "Result: " + x
         for i in 1 to 3 {
           output "Loop: " + i
         }
         EOF
       fi
    
       echo "Compiling with CompilerRunner..."
    
       # Run compiler - it will generate program.s in current directory
       java -cp "target/classes:lib/antlr4-runtime-4.13.2.jar" cdrv.runner.CompilerRunner --native src/main/cdrv/test.cdrv
       
       # Check for assembly file in multiple possible locations
       if [ -f "program.s" ]; then
         echo "Assembly generated in current directory"
         mkdir -p src/generated
         mv program.s src/generated/program.s
       elif [ -f "/storage/emulated/0/program.s" ]; then
         echo "Assembly generated in Android path (simulated)"
         mkdir -p src/generated
         cp "/storage/emulated/0/program.s" src/generated/program.s
       else
         # Try to find it anywhere
         FOUND_FILE=$(find . -name "program.s" -type f | head -1)
         if [ -n "$FOUND_FILE" ]; then
           echo "Found assembly at: $FOUND_FILE"
           mkdir -p src/generated
           cp "$FOUND_FILE" src/generated/program.s
         else
           echo "ERROR: No assembly file generated"
           echo "Listing files in current directory:"
           ls -la
           exit 1
         fi
       fi
    
       # Final verification
       if [ -f "src/generated/program.s" ]; then
         echo "Assembly generated successfully for ${{ matrix.target }}"
         echo "=== First 20 lines of generated assembly ==="
         head -20 src/generated/program.s
      
         # Copy to build directory
         mkdir -p build/${{ matrix.target }}
         cp src/generated/program.s build/${{ matrix.target }}/program.s
       else
         echo "ERROR: Assembly file not found after generation"
         exit 1
       fi
    
    - name: Assemble for ${{ matrix.target }}
      run: |
        cd build/${{ matrix.target }}
        echo "Assembling with ${{ matrix.as }}..."
        ${{ matrix.as }} program.s -o program.o
        
        if [ -f "program.o" ]; then
          echo "Object file created successfully"
          ${{ matrix.objdump }} -h program.o | head -10
        else
          echo "ERROR: Object file not created"
          exit 1
        fi
    
    - name: Link executable for ${{ matrix.target }}
      run: |
        cd build/${{ matrix.target }}
        echo "Linking executable..."
        
        # Use your runtime.c from the correct location
        if [ -f "../../src/main/c/runtime.c" ]; then
          echo "Using runtime.c from src/main/c/"
          ${{ matrix.gcc }} -static -o program program.o ../../src/main/c/runtime.c
        else
          echo "WARNING: src/main/c/runtime.c not found, creating minimal runtime"
          cat > minimal_runtime.c << 'EOF'
          #include <stdio.h>
          void runtime_print(char* str) { printf("%s\n", str); }
          char* runtime_int_to_string(int val) { 
              static char buf[32]; snprintf(buf, 32, "%d", val); return buf; 
          }
          char* string_concat(char* a, char* b) {
              static char buf[256]; snprintf(buf, 256, "%s%s", a, b); return buf;
          }
          EOF
          ${{ matrix.gcc }} -static -o program program.o minimal_runtime.c
        fi
        
        if [ -f "program" ]; then
          echo "Executable created successfully"
          file program
          # Add target suffix to avoid overwrites
          mv program program_${{ matrix.target }}
        else
          echo "ERROR: Executable not created"
          exit 1
        fi
    
    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.target }}-binaries
        path: build/${{ matrix.target }}/program_${{ matrix.target }}
        retention-days: 7

  # Test with QEMU for ARM64
  test-arm64:
    runs-on: ubuntu-latest
    needs: multi-arch-compile
    
    steps:
    - name: Download ARM64 artifacts
      uses: actions/download-artifact@v4
      with:
        name: aarch64-binaries
        path: test-artifacts/arm64
    
    - name: Install QEMU for ARM testing
      run: |
        sudo apt-get update
        sudo apt-get install -y qemu-user qemu-user-static
    
    - name: Test ARM64 binary with QEMU
      run: |
        cd test-artifacts/arm64
        if [ -f "program_aarch64" ]; then
          echo "Testing ARM64 binary with QEMU:"
          qemu-aarch64-static program_aarch64 || echo "Program executed (exit code: $?)"
        else
          echo "ERROR: ARM64 binary not found"
          exit 1
        fi

  # Native test for x86_64
  test-x86_64:
    runs-on: ubuntu-latest
    needs: multi-arch-compile
    
    steps:
    - name: Download x86_64 artifacts
      uses: actions/download-artifact@v4
      with:
        name: x86_64-binaries
        path: test-artifacts/x64
    
    - name: Test x86_64 binary natively
      run: |
        cd test-artifacts/x64
        if [ -f "program_x86_64" ]; then
          echo "Testing x86_64 binary natively:"
          ./program_x86_64 || echo "Program executed (exit code: $?)"
        else
          echo "ERROR: x86_64 binary not found"
          exit 1
        fi

  # Bytecode compilation test
  bytecode-test:
    runs-on: ubuntu-latest
    needs: build-compiler
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up JDK
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
    
    - name: Build compiler
      run: |
        find src/main/java -name "*.java" > sources.txt
        mkdir -p target/classes
        javac -cp "lib/antlr4-runtime-4.13.2.jar" -d target/classes @sources.txt
    
    - name: Test bytecode generation on all .cdrv files
      run: |
        echo "Testing bytecode generation for all .cdrv files:"
        find src/main/cdrv -name "*.cdrv" -type f | while read cdrv_file; do
          echo "Compiling: $cdrv_file"
          java -cp "target/classes:lib/antlr4-runtime-4.13.2.jar" cdrv.runner.CompilerRunner --bytecode "$cdrv_file" || echo "Bytecode generation completed for $cdrv_file"
        done

  # Run interpreter tests
  interpreter-test:
    runs-on: ubuntu-latest
    needs: build-compiler
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up JDK
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
    
    - name: Build compiler
      run: |
        find src/main/java -name "*.java" > sources.txt
        mkdir -p target/classes
        javac -cp "lib/antlr4-runtime-4.13.2.jar" -d target/classes @sources.txt
    
    - name: Test interpreter on .cdrv files
      run: |
        echo "Testing interpreter execution:"
        find src/main/cdrv -name "*.cdrv" -type f | head -2 | while read cdrv_file; do
          echo "Running: $cdrv_file"
          java -cp "target/classes:lib/antlr4-runtime-4.13.2.jar" cdrv.runner.InterpreterRunner "$cdrv_file" || echo "Interpreted $cdrv_file"
        done

  # Create comprehensive release
  release:
    runs-on: ubuntu-latest
    needs: [test-arm64, test-x86_64, bytecode-test, interpreter-test]
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up JDK
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
    
    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: release-artifacts
    
    - name: Create release package
      run: |
        mkdir -p coderive-release
        
        # Copy binaries
        mkdir -p coderive-release/bin
        cp release-artifacts/aarch64-binaries/program_aarch64 coderive-release/bin/ 2>/dev/null || true
        cp release-artifacts/x86_64-binaries/program_x86_64 coderive-release/bin/ 2>/dev/null || true
        
        # Copy source examples
        mkdir -p coderive-release/examples
        cp -r src/main/cdrv/* coderive-release/examples/ 2>/dev/null || true
        
        # Copy runtime
        mkdir -p coderive-release/src
        cp -r src/main/c coderive-release/src/ 2>/dev/null || true
        cp -r src/main/java coderive-release/src/ 2>/dev/null || true
        
        # Copy ANTLR dependency
        mkdir -p coderive-release/lib
        cp lib/antlr4-runtime-4.13.2.jar coderive-release/lib/ 2>/dev/null || true
        
        # Copy documentation
        cp LICENSE coderive-release/ 2>/dev/null || true
        cp README.md coderive-release/ 2>/dev/null || true
        
        # Create a comprehensive README
        cat > coderive-release/README.md << 'EOF'
        # Coderive Programming Language
        
        Multi-architecture compiler and runtime.
        
        ## Quick Start
        
        ### Run Pre-compiled Examples
        ```bash
        # ARM64 (Raspberry Pi, ARM servers)
        ./bin/program_aarch64
        
        # x86_64 (Most laptops/desktops)
        ./bin/program_x86_64
        ```
        
        ### Compile Your Own Programs
        ```bash
        # Build the Java compiler first (requires ANTLR runtime)
        find src/main/java -name "*.java" > sources.txt
        javac -cp "lib/antlr4-runtime-4.13.2.jar" -d target/classes @sources.txt
        
        # Compile a .cdrv file to native executable
        java -cp "target/classes:lib/antlr4-runtime-4.13.2.jar" cdrv.runner.CompilerRunner --native examples/your_program.cdrv
        ```
        
        ## Project Structure
        ```
        src/
          main/
            java/cdrv/     # Compiler source code
            cdrv/          # Example Coderive programs  
            c/             # Runtime C library
          generated/       # Auto-generated assembly files
        lib/
          antlr4-runtime-4.13.2.jar  # Parser runtime dependency
        ```
        EOF
        
        # Create zip package
        zip -r coderive-release.zip coderive-release/
        
        echo "Release package created: coderive-release.zip"
    
    - name: Upload release package
      uses: actions/upload-artifact@v4
      with:
        name: coderive-complete-release
        path: coderive-release.zip
        retention-days: 30

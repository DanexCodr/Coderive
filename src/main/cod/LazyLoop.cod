unit test (main: LazyLoop) // broadcasting throughout entire package

LazyLoop {
    share main() {
        // Test timer() first - simplified
        outln("Testing timer() function:")
        t1 := timer()
        t2 := timer()
        outln("Timer resolution: " + (t2 - t1) + " ms")
        outln()
        
        arr := [0 to 1Qi] // 1 Quintillion
        
        // Test the condition directly
        outln("Testing condition evaluation:")
        outln("2 % 2 = " + (2 % 2))
        outln("2 % 2 == 0 = " + (2 % 2 == 0))
        outln("3 % 2 = " + (3 % 2))
        outln("3 % 2 == 0 = " + (3 % 2 == 0))
        
        // Also test with larger numbers
        outln("24000 % 2 = " + (24K % 2))
        outln("24000 % 2 == 0 = " + (24K % 2 == 0))
        
        // Time the loop optimization
        start := timer()
        for i in [0 to 1Qi] {
            if i % 2 == 0 {
                arr[i] = "even"
            } elif i % 2 == 1 {
                arr[i] = "odd"
            }
        }
        loop_time := timer() - start
        outln("\nConditional formula creation time: " + loop_time + " ms")

        outln("\nResults:")
        outln("arr[2] = " + arr[2])
        outln("arr[3] = " + arr[3])
        outln("arr[24000] = " + arr[24K])
        outln("arr[24001] = " + arr[24001])
        
        // Test the 2-statement pattern optimization with timing
        outln("\n=== Testing 2-statement pattern optimization ===")
        
        arr2 := [0 to 1Qi]
        
        start = timer()
        for i in arr2 {
            squared := i * i
            arr2[i] = squared + 5
        }
        pattern_time := timer() - start
        outln("Pattern optimization time: " + pattern_time + " ms")
        
        outln("arr2[3] = " + arr2[3] + " (should be 3*3 + 5 = 14)")
        outln("arr2[5] = " + arr2[5] + " (should be 5*5 + 5 = 30)")
        outln("arr2[10] = " + arr2[10] + " (should be 10*10 + 5 = 105)")
        
        // Test with different variable names
        arr3 := [0 to 1Qi]
        
        start = timer()
        for i in arr3 {
            temp := i * 2
            arr3[i] = temp - 7
        }
        var_time := timer() - start
        outln("\nVariable substitution time: " + var_time + " ms")
        
        outln("arr3[4] = " + arr3[4] + " (should be 4*2 - 7 = 1)")
        outln("arr3[8] = " + arr3[8] + " (should be 8*2 - 7 = 9)")
        
        // Test that it still works with conditional
        outln("\n=== Testing conditional + 2-statement ===")
        
        arr4 := [0 to 100]
        
        start = timer()
        for i in arr4 {
            if i > 50 {
                doubled := i * 2
                arr4[i] = doubled + 1
            } else {
                arr4[i] = i
            }
        }
        mixed_time := timer() - start
        outln("Mixed optimization time: " + mixed_time + " ms")
        
        outln("arr4[30] = " + arr4[30] + " (should be 30)")
        outln("arr4[60] = " + arr4[60] + " (should be 60*2 + 1 = 121)")

        // ============ NEW: RANGE INDEXING TESTS ============
        outln("\n=== Testing Range Indexing ===")
        
        // Create a smaller array for testing
        testArr := [1 to 100]  // Numbers 1 to 100
        
        outln("\n1. Basic range indexing:")
        // Get a range slice
        slice1 := testArr[10 to 20]
        outln("testArr[10 to 20]:")
        outln("  First element: " + slice1[0])
        outln("  Element at index 5: " + slice1[5])
        outln("  Last accessible index: " + slice1[10])
        
        // Test with step
        outln("\n2. Range indexing with step:")
        slice2 := testArr[by 2 in 10 to 30]
        outln("testArr[by 2 in 10 to 30]:")
        // Show first few elements
        outln("  First 3 elements: " + slice2[0] + ", " + slice2[1] + ", " + slice2[2])
        
        // Test with negative step (reverse)
        outln("\n3. Reverse range indexing:")
        slice3 := testArr[30 to 10]
        outln("testArr[30 to 10]:")
        outln("  First element: " + slice3[0] + " (should be 31)")
        outln("  Second element: " + slice3[1] + " (should be 30)")
        outln("  Last element: " + slice3[20] + " (should be 11)")
        
        // Test multiple ranges
        outln("\n4. Multiple range indexing:")
        slice4 := testArr[1 to 5, 10 to 15, 20 to 25]
        outln("testArr[1 to 5, 10 to 15, 20 to 25]:")
        outln("  First element: " + slice4[0] + " (should be 2)")
        outln("  Element at index 6: " + slice4[6] + " (should be 12)")
        outln("  Element at index 15: " + slice4[15] + " (should be 25)")
        
        // Test range indexing assignment
        outln("\n5. Range indexing assignment:")
        assignArr := [0 to 50]
        assignArr[10 to 20] = 999
        outln("After assignArr[10 to 20] = 999:")
        outln("  assignArr[10] = " + assignArr[10] + " (should be 999)")
        outln("  assignArr[15] = " + assignArr[15] + " (should be 999)")
        outln("  assignArr[25] = " + assignArr[25] + " (should be 25)")
        
        // Test step assignment
        outln("\n6. Step range assignment:")
        assignArr[by 3 in 0 to 30] = 777
        outln("After assignArr[by 3 in 0 to 30] = 777:")
        outln("  assignArr[0] = " + assignArr[0] + " (should be 777)")
        outln("  assignArr[3] = " + assignArr[3] + " (should be 777)")
        outln("  assignArr[6] = " + assignArr[6] + " (should be 777)")
        outln("  assignArr[1] = " + assignArr[1] + " (should be 1)")
        outln("  assignArr[2] = " + assignArr[2] + " (should be 2)")
        
        // Test multiple range assignment
        outln("\n7. Multiple range assignment:")
        assignArr[40 to 45, 48 to 50] = 333
        outln("After assignArr[40 to 45, 48 to 50] = 333:")
        outln("  assignArr[40] = " + assignArr[40] + " (should be 333)")
        outln("  assignArr[44] = " + assignArr[44] + " (should be 333)")
        outln("  assignArr[49] = " + assignArr[49] + " (should be 333)")
        outln("  assignArr[46] = " + assignArr[46] + " (should be 46)")
        
        // Test with regular arrays (not NaturalArray)
        outln("\n8. Range indexing on regular array:")
        regularArr := ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"]
        regularSlice := regularArr[2 to 6]
        outln("regularArr[2 to 6]:")
        outln("  Elements: " + regularSlice[0] + ", " + regularSlice[1] + ", " + regularSlice[2] + ", " + regularSlice[3] + ", " + regularSlice[4])
        
        // Test assignment on regular array
        regularArr[0 to 2] = "Z"
        outln("After regularArr[0 to 2] = 'Z':")
        outln("  First 5 elements: " + regularArr[0] + ", " + regularArr[1] + ", " + regularArr[2] + ", " + regularArr[3] + ", " + regularArr[4])
        
        // Test negative indices (from end)
        outln("\n9. Negative indices (counting from end):")
        negArr := [1 to 10]
        outln("negArr[-1] = " + negArr[-1] + " (should be 10)")
        outln("negArr[-3] = " + negArr[-3] + " (should be 8)")
        outln("negArr[-5] = " + negArr[-5] + " (should be 6)")
        
        // Test negative range
        negSlice := negArr[-5 to -1]
        outln("negArr[-5 to -1] first element: " + negSlice[0] + " (should be 6)")
        outln("negArr[-5 to -1] last element: " + negSlice[4] + " (should be 10)")
        
        // Test chained range indexing
        outln("\n10. Chained range indexing:")
        matrix := [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]
        matrixSlice := matrix[1 to 2][0 to 1]  // Get rows 1-2, then columns 0-1
        outln("matrix[1 to 2][0 to 1]:")
        outln("  Element at [0][0]: " + matrixSlice[0][0] + " (should be 5)")
        outln("  Element at [0][1]: " + matrixSlice[0][1] + " (should be 6)")
        outln("  Element at [1][0]: " + matrixSlice[1][0] + " (should be 9)")
        
        // Test performance with range indexing
        outln("\n11. Performance test with range indexing:")
        bigArr := [0 to 1M]  // 1 million elements
        
        start = timer()
        bigArr[by 1000 in 0 to 1M] = "batch"
        rangeAssignTime := timer() - start
        outln("Setting every 1000th element in 1M array: " + rangeAssignTime + " ms")
        outln("bigArr[0] = " + bigArr[0] + " (should be 'batch')")
        outln("bigArr[1000] = " + bigArr[1000] + " (should be 'batch')")
        outln("bigArr[500] = " + bigArr[500] + " (should be 500)")
        
        // Compare with traditional loop
        start = timer()
        for i in [by 1000 in 0 to 1M] {
            bigArr[i] = "loop"
        }
        loopAssignTime := timer() - start
        outln("Same operation with loop: " + loopAssignTime + " ms")
        
        // Test edge cases
        outln("\n12. Edge cases:")
        edgeArr := [1 to 5]
        
        // Single element range
        single := edgeArr[3 to 3]
        outln("edgeArr[3 to 3][0] = " + single[0] + " (should be 4)")
        
        // Test that invalid ranges produce errors by checking specific indices
        outln("\n13. Verifying array integrity after operations:")
        outln("Original testArr[15] = " + testArr[15] + " (should be 16)")
        outln("Original testArr[25] = " + testArr[25] + " (should be 26)")
        outln("Modified assignArr[35] = " + assignArr[35] + " (should be 35)")
        outln("Modified assignArr[47] = " + assignArr[47] + " (should be 47)")
        
        // Test that we can still use regular indexing
        outln("\n14. Mixed regular and range indexing:")
        mixedArr := [0 to 100]
        mixedArr[50] = "middle"
        mixedArr[25 to 30] = "range"
        outln("mixedArr[49] = " + mixedArr[49] + " (should be 49)")
        outln("mixedArr[50] = " + mixedArr[50] + " (should be 'middle')")
        outln("mixedArr[27] = " + mixedArr[27] + " (should be 'range')")
        outln("mixedArr[75] = " + mixedArr[75] + " (should be 75)")
        
        outln("\n=== All tests completed ===")
        
        // Summary
        outln("\n=== Range Indexing Summary ===")
        outln("✓ Basic range indexing: arr[2 to 40]")
        outln("✓ Step range indexing: arr[by 2 in 10 to 60]")
        outln("✓ Multiple ranges: arr[6 to 10, 12 to 24]")
        outln("✓ Range assignment: arr[2 to 40] = value")
        outln("✓ Negative indices: arr[-5 to -1]")
    }
}

Hello {}

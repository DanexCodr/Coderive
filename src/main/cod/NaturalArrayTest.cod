share main() {
    outln("=== NUMBER TYPE PRECISION TEST ===\n")
    
    // Test 1: Integer type boundaries
    outln("1. Testing integer type boundaries:")
    
    // Small (should be Integer)
    small := 42
    outln("   small = " + small + " (should be 42)")
    
    // Medium (should be Long)
    medium := 9223372036854775807  // Long.MAX_VALUE
    outln("   medium = Long.MAX_VALUE = " + medium)
    
    // Check if we can add 1 without overflow
    mediumPlus1 := medium + 1
    outln("   medium + 1 = " + mediumPlus1 + " (what happens?)")
    
    // Huge (what does this become?)
    huge := 999999999999999999999999999999999
    outln("   huge = " + huge)
    outln("   Is huge exact? " + (huge.toString().length() > 15 ? "Probably not" : "Maybe"))
    
    // Test 2: Floating-point precision
    outln("\n2. Testing floating-point precision:")
    
    a := 0.1
    b := 0.2
    c := a + b
    outln("   0.1 = " + a)
    outln("   0.2 = " + b)
    outln("   0.1 + 0.2 = " + c)
    outln("   0.1 + 0.2 == 0.3? " + (c == 0.3))
    outln("   Difference: " + (c - 0.3))
    
    // Test 3: Large integer preservation in NaturalArray
    outln("\n3. Testing NaturalArray with large numbers:")
    
    // Create array with huge bounds
    bigArray := [1000000000000 to 1000000000005]  // 1 trillion to 1 trillion + 5
    outln("   Created: " + bigArray)
    
    for i in 0 to 5 {
        outln("   bigArray[" + i + "] = " + bigArray[i])
    }
    
    // Modify with large number
    bigArray[2] = 888888888888888888888
    outln("   After setting bigArray[2] = 888888888888888888888:")
    outln("   bigArray[2] = " + bigArray[2])
    
    // Test 4: Arithmetic with huge numbers
    outln("\n4. Testing arithmetic operations:")
    
    x := 100000000000000000000
    y := 200000000000000000000
    sum := x + y
    product := x * 3
    
    outln("   x = " + x)
    outln("   y = " + y)
    outln("   x + y = " + sum + " (should be 300000000000000000000)")
    outln("   x * 3 = " + product + " (should be 300000000000000000000)")
    
    // Test 5: Division and fractions
    outln("\n5. Testing division:")
    
    div1 := 1.0 / 3.0
    div2 := 1 / 3
    outln("   1.0 / 3.0 = " + div1)
    outln("   1 / 3 = " + div2 + " (integer division?)")
    
    // Test 6: Type inference
    outln("\n6. Testing type inference:")
    
    inferred1 := 42
    inferred2 := 42.0
    inferred3 := 100000000000000000000
    
    outln("   inferred1 := 42 â†’ type? value = " + inferred1)
    outln("   inferred2 := 42.0 â†’ type? value = " + inferred2)
    outln("   inferred3 := 100000000000000000000 â†’ type? value = " + inferred3)
    
    // Test 7: Edge cases
    outln("\n7. Testing edge cases:")
    
    // Very precise decimal
    precise := 3.14159265358979323846264338327950288419716939937510
    outln("   Ï€ to 50 digits = " + precise)
    outln("   Actual stored length: " + precise.toString().length() + " chars")
    
    // Scientific notation
    scientific := 6.02214076e23
    outln("   Avogadro's number = " + scientific)
    
    outln("\n=== ANALYSIS ===")
    outln("Based on these tests:")
    outln("1. If huge integers preserve all digits â†’ You have BigInteger!")
    outln("2. If 0.1 + 0.2 == 0.3 exactly â†’ You have exact decimals!")
    outln("3. If NaturalArray works with huge bounds â†’ Formula computation works!")
    
    outln("\nCurrent findings from your code:")
    outln("â€¢ Your 'int' handles: Integer (32-bit), Long (64-bit), Double (lossy for huge)")
    outln("â€¢ Your 'float' is Java's double (64-bit IEEE 754)")
    outln("â€¢ NaturalArray uses double for calculations")
    
    outln("\nRecommendations:")
    outln("1. To name them 'exact'/'prec': Implement BigInteger/BigDecimal")
    outln("2. Keep 'int'/'float': Be honest about limitations")
    outln("3. NaturalArray is already revolutionary regardless!")
    
    outln("\nRun this test to see the truth! ğŸ”")
}